<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="RichTextBox1.Text" xml:space="preserve">
    <value>If...End If

La sintaxis de esta estructura puede aplicarse de diferentes formas en función del tipo de decisión a
resolver.

Decisión simple.

If Expresión Then
' código
' ......
' ......
End If

Si al evaluar Expresión se devuelve como resultado Verdadero, se ejecutarán las líneas o bloque de
código comprendido entre If y End If. Si Expresión es Falso, se desviará la ejecución a la primera
línea de código que haya después de End If.



Decisión simple en una línea.

En el caso de que sólo haya que ejecutar una instrucción sencilla cuando se cumple la expresión de la
estructura, podemos omitir la palabra clave End If, escribiendo la sentencia a ejecutar en la misma
línea de la declaración de la estructura If, justo a continuación de la palabra Then. La sintaxis en este
caso, se simplifica.

If Expresión Then Instrucción

Veamos un ejemplo en el Código

Sub Main()
     Dim Valor As Integer
     Dim Resultado As Integer
    Console.WriteLine("Introducir un número")
    Valor = Console.ReadLine()
    If Valor = 5 Then Resultado = Valor + 10
    Console.WriteLine("La variable resultado contiene {0}", Resultado)
    Console.ReadLine()
End Sub


Como habrá comprobado el lector, la sentencia que hay a continuación de Then sólo se ejecutará
cuando la variable Valor contenga 5.

Decisión doble.

Además de ejecutar un bloque de código cuando la expresión valga Verdadero, podemos también
ejecutar código cuando la expresión devuelva Falso. En este caso añadiremos a la estructura la palabra
clave Else, como muestra la sintaxis del Código

If Expresión Then
' código cuando Expresión es Verdadero
' ......
' ......
Else
' código cuando Expresión es Falso
' ......
' ......
End If


Decisión doble en una línea.

Al igual que ocurre con la decisión simple, si para cada resultado de la expresión, sólo necesitamos
ejecutar una instrucción, podemos escribir todo el código en una sola línea. Veamos la sintaxis en el
Código fuente

If Expresión Then InstrucciónVerdadero Else InstrucciónFalso


Si bien la ejecución de la estructura If en una línea puede ser útil en ocasiones, tiene como
contrapartida el que nuestro código se vuelva más difícil de leer. Por ello es más recomendable el uso
de esta estructura de control en su formato If...End If.

Decisión múltiple.

En el caso de que la expresión principal a evaluar devuelva Faso, podemos agregar expresiones
adicionales utilizando la palabra clave ElseIf, con su bloque de código respectivo. En el caso de que
ninguna de ellas se cumplan, podemos incluir un Else, para ejecutar un bloque de código por defecto.
Veamos la sintaxis en el Código fuente

If ExpresiónA Then
' código cuando ExpresiónA es Verdadero
' .......
ElseIf ExpresiónB Then
' código cuando ExpresiónB es Verdadero
' .......
[ElseIf ExpresiónN Then]
' código cuando ExpresiónN es Verdadero
' .......
[Else]
' código cuando ninguna epxresión devuelve Verdadero
' .......
End If

En esta situación, si la primera expresión es Verdadero, se ejecutará el código situado a partir de If.
Sin embargo, si If devuelve Falso, se comprobarán sucesivamente las expresiones de cada uno de los
ElseIf existentes. En el caso de algún ElseIf devuelva Verdadero, se ejecutará el código que haya a
partir del mismo. Si ninguna de las anteriores situaciones se cumple, se ejecutará el código que haya a
partir de Else en el caso de que este se haya definido.</value>
  </data>
  <data name="AxWindowsMediaPlayer1.OcxState" mimetype="application/x-microsoft.net.object.binary.base64">
    <value>
        AAEAAAD/////AQAAAAAAAAAMAgAAAFdTeXN0ZW0uV2luZG93cy5Gb3JtcywgVmVyc2lvbj00LjAuMC4w
        LCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkFAQAAACFTeXN0
        ZW0uV2luZG93cy5Gb3Jtcy5BeEhvc3QrU3RhdGUBAAAABERhdGEHAgIAAAAJAwAAAA8DAAAAzQAAAAIB
        AAAAAQAAAAAAAAAAAAAAALgAAAAAAwAACAAWAAAAVgBpAGQAZQBvADEALgAzAGcAcAAAAAUAAAAAAAAA
        8D8DAAAAAAAFAAAAAAAAAAAACAACAAAAAAADAAEAAAALAP//AwAAAAAACwD//wgAAgAAAAAAAwAyAAAA
        CwAAAAgACgAAAG4AbwBuAGUAAAALAAAACwAAAAsA//8LAP//CwAAAAgAAgAAAAAACAACAAAAAAAIAAIA
        AAAAAAgAAgAAAAAACwAAANwmAAC0GAAACw==
</value>
  </data>
</root>